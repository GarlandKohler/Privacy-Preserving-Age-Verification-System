// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { FHE, euint32, inEuint32 } from "@fhevm/solidity/lib/FHE.sol";
import { SepoliaConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Input Proof Example
/// @notice Demonstrates input proofs and how they work
/// @dev Key concepts:
/// - What are input proofs?
/// - Why input proofs are necessary
/// - How to use input proofs correctly
/// - Common mistakes with input proofs
contract InputProofExample is SepoliaConfig {
    /// @notice Stores encrypted values
    mapping(address => euint32) private values;

    /// @notice Event emitted when value is stored
    event ValueStored(address indexed user);

    /// @notice What are input proofs?
    ///
    /// Input proofs are zero-knowledge proofs that verify:
    /// 1. The encrypted input is correctly formatted
    /// 2. The input is properly bound to [contract, user] pair
    /// 3. The encryption scheme was used correctly
    ///
    /// Without input proofs, malicious users could:
    /// - Submit invalid encrypted data
    /// - Submit data encrypted for wrong contract/user
    /// - Cause undefined behavior or attacks
    ///
    /// @notice Why input proofs are necessary:
    ///
    /// The FHE system encrypts values such that they're bound to:
    /// - Specific contract address
    /// - Specific user address
    ///
    /// A proof ensures that when User A submits data to ContractB,
    /// it was actually encrypted for ContractB by User A,
    /// not copied from another contract or user.

    /// @notice Store encrypted value with valid proof
    /// @param input Encrypted value (from client-side FHE library)
    /// @param inputProof ZK proof of correct encryption
    /// @dev Correct usage: input and proof must match
    function storeValueCorrectly(inEuint32 calldata input, bytes calldata inputProof) external {
        // FHE.asEuint32 validates the proof
        // If proof is invalid or doesn't match input, this reverts
        euint32 encryptedValue = FHE.asEuint32(input, inputProof);

        values[msg.sender] = encryptedValue;

        FHE.allowThis(encryptedValue);
        FHE.allow(encryptedValue, msg.sender);

        emit ValueStored(msg.sender);
    }

    /// @notice Get value with proof validation
    /// @return euint32 The encrypted value
    function getValue() external view returns (euint32) {
        return values[msg.sender];
    }

    /// @notice Example showing how to generate correct input
    /// @dev From client side (JavaScript/TypeScript):
    ///
    /// // ✅ CORRECT WAY:
    /// import { FheVm } from "@zama-fhe/fhevm";
    ///
    /// const fhevm = new FheVm({
    ///   networkUrl: "http://localhost:8545"
    /// });
    ///
    /// // Encrypt the value, binding it to this contract and user
    /// const encrypted = await fhevm.createEncryptedInput(contractAddress, userAddress)
    ///   .add32(123)  // Add 32-bit encrypted value
    ///   .encrypt();
    ///
    /// // encrypted.handles[0] = the encrypted value
    /// // encrypted.inputProof = the proof
    ///
    /// // Send to contract
    /// const tx = await contract.storeValueCorrectly(
    ///   encrypted.handles[0],
    ///   encrypted.inputProof
    /// );
    ///
    /// @dev This ensures:
    /// - Value is encrypted correctly
    /// - Proof is valid
    /// - Binding to contract and user is correct
    function correctClientExample() external pure {
        // Documentation only - implementation is on client-side
    }

    /// @notice ❌ ANTI-PATTERN: Wrong order of parameters
    /// Swapping input and proof will cause validation failure
    function BAD_swappedParameters(inEuint32 calldata input, bytes calldata inputProof) external {
        // ❌ Swapping these causes validation failure
        // euint32 encryptedValue = FHE.asEuint32(inputProof, input);
        // Error: inputProof is not valid encrypted data
        // Error: input is not a valid proof
    }

    /// @notice ❌ ANTI-PATTERN: Using proof from different user
    /// If user A encrypts for themselves, then user B submits
    /// user A's input with user A's proof, it will fail
    function BAD_wrongUserProof(
        inEuint32 calldata input,
        bytes calldata userAProof  // Proof generated by different user
    ) external {
        // ❌ This fails because the proof is bound to different user
        // euint32 encryptedValue = FHE.asEuint32(input, userAProof);
        // Error: Proof validation fails (proof is for different user)
    }

    /// @notice ❌ ANTI-PATTERN: Using proof from different contract
    /// If data is encrypted for ContractA, submitting to ContractB fails
    function BAD_wrongContractProof(
        inEuint32 calldata input,
        bytes calldata contractAProof  // Proof generated for different contract
    ) external {
        // ❌ This fails because the proof is bound to different contract
        // euint32 encryptedValue = FHE.asEuint32(input, contractAProof);
        // Error: Proof validation fails (proof is for different contract)
    }

    /// @notice ❌ ANTI-PATTERN: Reusing same input/proof multiple times
    /// Each transaction should generate fresh input and proof
    /// Reusing proofs could potentially be exploited
    function BAD_reusingSameProof(inEuint32 calldata input, bytes calldata inputProof) external {
        euint32 value1 = FHE.asEuint32(input, inputProof);
        values[msg.sender] = value1;

        FHE.allowThis(value1);
        FHE.allow(value1, msg.sender);

        // ❌ Never reuse the same proof
        // If you call this function again with same input/proof,
        // it may succeed but is bad practice
        // Always generate fresh proofs for each transaction
    }

    /// @notice ❌ ANTI-PATTERN: Not validating proof at all
    /// (Hypothetical - cannot actually be done without FHE.asEuint32)
    /// This is why FHE.asEuint32 is important
    function BAD_hypothetical_noProofValidation() external {
        // In theory, without proof validation:
        // - Malicious user could submit random encrypted bytes
        // - Could submit data encrypted for other users/contracts
        // - Could cause security vulnerabilities
        //
        // This is prevented by requiring valid input and proof
        // in FHE.asEuint32() call
    }

    /// @notice Common mistakes with input proofs:
    /// 1. Forgetting to validate the proof at all
    /// 2. Using proof from different user
    /// 3. Using proof from different contract
    /// 4. Reusing proofs across transactions
    /// 5. Swapping input and proof parameters
    /// 6. Invalid input format
    /// 7. Corrupted proof data
    ///
    /// @notice Best practices:
    /// 1. Always use FHE.asEuint32/asEuint8/asEuint16 with proof
    /// 2. Generate fresh input and proof for each transaction
    /// 3. Ensure client-side encryption uses correct contract address
    /// 4. Ensure client-side encryption uses correct user address
    /// 5. Validate that proof validation succeeds (transaction will revert otherwise)
    /// 6. Store encrypted values immediately after proof validation
    function bestPractices() external pure {
        // Documentation only
    }
}
